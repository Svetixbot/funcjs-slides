## Principles

  - avoid hidden side-effects
  - ensure referential transparency (what readability means)
  - use list-processing functions rather than loops where it makes sense
  [martin fowler's stuff](https://martinfowler.com/articles/collection-pipeline/)

**Talk about what these mean**

---

## Human First approach
Steal YOW 2017 slides about how code is a small part of a human problem and that FP makes the humans happy.

---
## FP in JS

---

## Functional composition

---

## Currying

---

## Transformer

[I want to talk about this at some point because it is cool.](https://perfunct.tech/javascript/2018/03/12/manageable-data-transform/)

---

Then, there was safety.

I guess we all got sick of NullReferenceException and 'undefined is not an object.'.
Or the situations when we get a stack trace in our face.

There is a better way of handling it.
Either and Maybe monads!

---

Do not repeat yourself.

DRY principle taken really seriously.

Feed.
Collect (feed => {feed.source, feed.time, feed.topic}).
Filter(feed => aboutStuff(feed.topic))((summary, Right(rejectionReason)) => summary + Summary(rejection = rejectionReason))
sink(toDatabase)((summary, Right(error)) => summary + Summary(rejection = rejectionReason))
sink(toExternalApi)((summary, Right(error)) => summary + Summary(rejection = rejectionReason))

(+): semigroup concept

---

Type driven development.

type Amount = Double Currency
type Currency = AUD | USD | RUR
convert: Amount -> Currency -> Amount

---

Test coverage is a lie and property-based testing

---